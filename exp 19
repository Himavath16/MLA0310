import numpy as np
import random
import math
campaigns = ["Email", "SMS", "Social", "Influencer", "Ads"]
true_conversion_rates = [0.25, 0.15, 0.30, 0.35, 0.20]  
k = len(campaigns)
steps = 1000
runs = 50
def epsilon_greedy(epsilon=0.1):
    Q = np.zeros(k)
    N = np.zeros(k)
    total_reward = 0

    for _ in range(steps):
        if random.random() < epsilon:
            a = random.randint(0, k - 1)
        else:
            a = np.argmax(Q)

        reward = 1 if random.random() < true_conversion_rates[a] else 0
        N[a] += 1
        Q[a] += (reward - Q[a]) / N[a]
        total_reward += reward

    return total_reward
def ucb():
    Q = np.zeros(k)
    N = np.zeros(k)
    total_reward = 0

    for t in range(1, steps + 1):
        if 0 in N:
            a = np.argmin(N)  
        else:
            ucb_values = Q + np.sqrt(2 * np.log(t) / N)
            a = np.argmax(ucb_values)

        reward = 1 if random.random() < true_conversion_rates[a] else 0
        N[a] += 1
        Q[a] += (reward - Q[a]) / N[a]
        total_reward += reward

    return total_reward
def thompson_sampling():
    successes = np.ones(k)
    failures = np.ones(k)
    total_reward = 0

    for _ in range(steps):
        sampled_theta = [
            np.random.beta(successes[i], failures[i]) for i in range(k)
        ]
        a = np.argmax(sampled_theta)

        reward = 1 if random.random() < true_conversion_rates[a] else 0
        if reward == 1:
            successes[a] += 1
        else:
            failures[a] += 1

        total_reward += reward

    return total_reward
results = {
    "Epsilon-Greedy": [],
    "UCB": [],
    "Thompson Sampling": []
}

for _ in range(runs):
    results["Epsilon-Greedy"].append(epsilon_greedy())
    results["UCB"].append(ucb())
    results["Thompson Sampling"].append(thompson_sampling())
print("Average Conversions over Multiple Runs:\n")
for algo, values in results.items():
    print(f"{algo}: {np.mean(values):.2f}")
